//
// Кодируем данные.
// Исправленный вариант.
//
function VRLE8Coding(array1, array2)
{

	// array1 - Массив с данными (числовой массив, каждая ячейка от 0 и до 255, байты).
	//          Это то, что нужно закодировать.

	// array2 - Массив с адресами повтор./неповтор (числовой массив).

	// Кодируем в arraycoding8.
	var arraycoding8 = [];

	var addr2, addrcoding, z1, z2, z3, b1;
	var tpor1, tpor2, swpor, t1, t2, z4;

	addrcoding = 0;

	for (addr2 = 0; addr2 < array2.length;)
		{
		// Кодирование.
		switch (array2[addr2])
			{

			// -------
			// Повтор.
			// -------

			// Минимальная порция - 2 байта.
			// Максимальная порция - 127 байт.

			case 1:

			// Байт, который нужно повторить.
			b1 = array1[array2[addr2 + 1]];

			tpor1 = array2[addr2 + 3]; // Сколько повтор.

			if (tpor1 < 127)
				{
				// Только часть порции.
				// В tpor1 - сколько повтор.
				swpor = 1;
				}
				else
				{
				t1 = 0;

				for(;;)
					{
					tpor1 = tpor1 - 127;
					t1++;

					if (tpor1 == 0)
						{
						// n-полных порций и нет неполной порции.
						// В t1 - сколько полных порций.
						swpor = 2;
						break;
						}

					if (tpor1 < 127)
						{
						// n-полных порций и часть порции.
						// В t1 - сколько полных порций.
						// В tpor1 - часть порции (сколько повтор.).
						swpor = 3;
						break;
						}
					}
				}

			switch (swpor)
				{
				case 1:

				// Логическое ИЛИ (|):
				//    0 0 | 0
				//    0 1 | 1
				//    1 0 | 1
				//    1 1 | 1

				// Только часть порции.

				// Записываем информационный байт.
				// Установить 7-й бит в 1, остальные биты оставить без изменений.
				arraycoding8[addrcoding++] = 128 | tpor1;

				// Записываем байт, который нужно повторить.
				arraycoding8[addrcoding++] = b1;

				break;

				case 2:

				// Только полная порция (полные порции).
				for (z1 = 0; z1 < t1;)
					{
					// Записываем информационный байт.
					// 7-й бит в 1 (7F => FF)!
					arraycoding8[addrcoding++] = 255;

					// Записываем байт, который нужно повторить.
					arraycoding8[addrcoding++] = b1;

					z1++;
					}

				break;

				case 3:

				// Полная порция (полные порции).
				for (z1 = 0; z1 < t1;)
					{
					// Записываем информационный байт.
					// 7-й бит в 1 (7F => FF)!
					arraycoding8[addrcoding++] = 255;

					// Записываем байт, который нужно повторить.
					arraycoding8[addrcoding++] = b1;

					z1++;
					}

				// Часть порции (остаток).

				// Записываем информационный байт.
				// Установить 7-й бит в 1, остальные биты оставить без изменений.
				arraycoding8[addrcoding++] = 128 | tpor1;

				// Записываем байт, который нужно повторить.
				arraycoding8[addrcoding++] = b1;

				break;
				}

			break;

			// ---------
			// Неповтор.
			// ---------

			// Минимальная порция - 1 байт.
			// Максимальная порция - 127 байт.

			case 0:

			// Начальный адрес неповтор.
			z3 = array2[addr2 + 1];

			tpor2 = array2[addr2 + 3]; // Сколько неповтор.

			if (tpor2 < 127)
				{
				// Только часть порции.
				// В tpor2 - сколько неповтор.
				swpor = 1;
				}
				else
				{
				t2 = 0;

				for(;;)
					{
					tpor2 = tpor2 - 127;
					t2++;

					if (tpor2 == 0)
						{
						// n-полных порций и нет неполной порции.
						// В t2 - сколько полных порций.
						swpor = 2;
						break;
						}

					if (tpor2 < 127)
						{
						// n-полных порций и часть порции.
						// В t2 - сколько полных порций.
						// В tpor2 - часть порции (сколько неповтор.).
						swpor = 3;
						break;
						}
					}
				}

			switch (swpor)
				{
				case 1:

				// Записываем информационный байт.
				// 7-й бит уже в 0!
				arraycoding8[addrcoding++] = tpor2;

				// Только часть порции.
				for (z2 = 0; z2 < tpor2;)
					{
					// Переписываем неповтор. байты.
					arraycoding8[addrcoding++] = array1[z3++];
					z2++;
					}

				break;

				case 2:

				// Только полная порция (только полные порции).
				for (z4 = 0; z4 < t2;)
					{
					// Записываем информационный байт.
					// Максимальный размер порции, плюс 7-й бит в 0.
					arraycoding8[addrcoding++] = 127;

					for (z2 = 0; z2 < 127;)
						{
						// Переписываем неповтор. байты.
						arraycoding8[addrcoding++] = array1[z3++];
						z2++;
						}
					z4++;
					}

				break;

				case 3:

				// Полная порция (полные порции).
				for (z4 = 0; z4 < t2;)
					{
					// Записываем информационный байт.
					// Максимальный размер порции, плюс 7-й бит в 0.
					arraycoding8[addrcoding++] = 127;

					for (z2 = 0; z2 < 127;)
						{
						// Переписываем неповтор. байты.
						arraycoding8[addrcoding++] = array1[z3++];
						z2++;
						}
					z4++;
					}

				// Часть порции (остаток).

				// Записываем информационный байт.
				// 7-й бит уже в 0!
				arraycoding8[addrcoding++] = tpor2;

				for (z2 = 0; z2 < tpor2;)
					{
					// Переписываем неповтор. байты.
					arraycoding8[addrcoding++] = array1[z3++];
					z2++;
					}

				break;
				}

			// Прервать switch.
			break;
			}
		addr2 = addr2 + 4;
		}

	// Вернуть закодированный массив.
	return arraycoding8;
}